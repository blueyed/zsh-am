* The Challenge

  The goal at which we'd like to end up, is a way to import commits send to
  zsh's mailing lists with as little manual labour as possible. The workflow
  for this kind of endavour - using git's pre-packaged means - would usually
  involve the use of "git am". In your Mail-User-Agent (MUA) you would mark and
  save the mail message that contain commits you want to import to an `mbox'
  folder - say "feature-x.mbox" - and run "git am" on that like so:

#+BEGIN_EXAMPLE
% git am feature-x.mbox
#+END_EXAMPLE

  With zsh's development style, that presents two issues:

    - Zsh uses a traditional ChangeLog file to linearly track changes.
    - Zsh also uses numbers from ezmlm's (the mailing list software) X-Seq:
      header to make it easy to dig up mailing list discussions that belong to
      the individual change listed in ChangeLog file.

  So in the end, the goal is to ideally have _one_ command that does this:

    - Look at the saved mbox file, prefix all Subject: headers with the
      corresponding X-Seq: number (extra sugar: detect if a commit mail was
      sent to zsh-users instead of zsh-workers and prefix the X-Seq: number
      with a "users/" string).
    - Commit all messages from the mbox file via "git am" and amend the commits
      with automatic updates to the ChangeLog file. This should reflect the
      X-Seq: number, files that were touched by the commit, as well as the
      title of the commit message (the first line of the commit, that is
      usually put into the Subject: header of commit mails).

* The Workflow

  With zsh, all codebase changes (except for trivial ones) go through one of
  its mailing lists (usually zsh-workers@zsh.org, but sometimes zsh-users, as
  well). What is more is this: The use of numbers from the X-Seq: header,
  require developers to amend every commit message. That means that you're
  doing integration work all the time even with your own changes.

  This is a workflow that works pretty well for myself and I think it's simple
  enough for others to adopt as well. This discusses not only the import of
  commits from the mailing-lists, but also how to get mails to the mailing-list
  that are properly formatted to be consumed by the usual git-tools, such as
  "git am". That's why this introduction is a little lengthy.

** Working on separate branches

   The branch in which zsh's development is going forward is "master".

   Branches in git are not scary at all. They are cheap to create, have lying
   around and easy to work with. I know that many people think "Why on earth
   would I be adding a new branch for this!?": But let's assume for the moment,
   that doing this will help in the end.

   Let's assume, we've got the master branch checked out and we'd like to work
   on "feature-x". I usually prefix my branches with my initials, so I'd do
   this:

#+BEGIN_EXAMPLE
% git checkout -b ft/feature-x
#+END_EXAMPLE

   Now I'd work, commit, work, commit, rework... whatever I need to do and git
   allows me to do. In the end, there will be one or more commits, that
   implement "feature-x".

** Using git's mail-related tools

   Git has a number of tools, that help mailing-list based development. In
   particular that would be "git format-patch" and "git send-email". The former
   generates files, that are properly formatted for consumption by the latter
   as well as git's other mail-related tools.

*** Commit messages

    Just as a reminder, commit messages with git - by convention - look like
    this:

#+BEGIN_EXAMPLE
The first line should be short and to the point about the change in the commit

The second line is to be left _EMPTY_!

The rest may go into as much detail about the changes as the author sees fit.
Information that could be included is: What changed? Why change it in the first
place? Why change it in this way and not in another fashion? Maybe parts of
mailing list discussions, if they are relevant.
#+END_EXAMPLE

*** "git format-patch"

    This helper program generates mail messages from a set of commits.

    Say we know, we have exactly three commits on our development branch. In
    that case we might call the program like this:

#+BEGIN_EXAMPLE
% git format-patch -3
#+END_EXAMPLE

    "-3" tells it to create mails for the last three commits.

    If you don't quite know how many commits you got, you can also tell
    format-patch to start at the point where you branched off (that would usually
    be the "master" branch) and tell it to stop whereever you are right now:

#+BEGIN_EXAMPLE
% git format-patch master..
#+END_EXAMPLE

    That's all. The result will be a number of "*.patch" files, that you can
    send off to whereever they need to be send to.

    If you're preparing larger patch-series, you might want to add a
    cover-mail, too. But that's beyond the scope of this document.

*** "git send-email"

    This section could be very very short. Because you can just feed the files
    from "format-patch" to "send-email" and be done with it. But there is another
    worthwhile feature we might as well look at.

    Mails generated by "format-patch" always contain a line with three dashes,
    followed by a few lines of diff-stat information before the actual diff is
    inserted. This is somewhere in the mail's body in looks somthing like this:

#+BEGIN_EXAMPLE
---
 Src/Zle/zle_main.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)
#+END_EXAMPLE

    Now, since those "*.patch" files are just plain-text email messages, you
    might be tempted to edit them using your favourite editor. And you can.

    The feature I'd like to highlight is, that any text you enter between the
    three-dashes-line and the diffstat will be discarded by "git am" (the tool
    that will ultimately import the commit for us later on). So you can use
    that space to add comments about the commit, that might be of interest for
    other people at the time, but doesn't deserve to be part of the actual
    commit message.

    The actual call to send off the generated mails, looks like this (I told
    you it would have been a short section without that other feature):

#+BEGIN_EXAMPLE
% git send-email --to='zsh-workers@zsh.org' --suppress-cc=all *.patch
#+END_EXAMPLE

    You can configure "send-email" so you have to supply less options, put the
    command line is still pretty short and zsh's git completion will help you
    construct it with ease.

** Receiving the messages

   Once you can see the messages in your MUA, you can probably mark them in
   some way and save them to a local folder (preferably "mbox" format, that's
   what I tested this solution with; although the module I used supports a wide
   variety of formats).

   If you MUA cannot do this: My condolences. ;)

** Importing the changes from the newly created mbox file

   This is actually the only section about the solution that is present with
   this little software package.

   First lets move to the "master" branch again (you could also do the import
   in another integration branch and merge that into "master" later, but lets
   not over-do things):

#+BEGIN_EXAMPLE
% git checkout master
#+END_EXAMPLE

   There are two steps that need to be taken (let's again assume
   "feature-x.mbox" as our newly created mbox file). First, amend the Subject:
   lines of the mails to reflect the X-Seq: number:

#+BEGIN_EXAMPLE
% zsh-am-xseq2subject feature-x.mbox
#+END_EXAMPLE

   This step needs to be taken exactly once.

   And finally, import the changes and amend ChangeLog along the way
   appropriately:

#+BEGIN_EXAMPLE
% zsh-am-and-changelog feature.mbox
#+END_EXAMPLE

   And that is it. Unless you get merge conflicts, in which case you need to do
   some manual labour after all.

   Obviously, having to enter more than one command is unacceptable, so here's
   a short-hand:

#+BEGIN_EXAMPLE
% zsh-am feature-x.mbox
#+END_EXAMPLE

   You can pass as many mbox files as you like to the short-hand command.

** Cleaning up

   One obvious step is to remove the mbox file. That's boring.

   More interestingly, there's still our development branch lying around. You
   can keep it, if you want to. But you can also just remove it, because your
   changes are now part of "master", albeit in amended form since the ChangeLog
   file was changed and the commit title got the X-Seq: number stuck to its
   front.

   So for the version control system, the changes are different. And that is
   finally, why it makes sense to code on separate branches for anything you
   send through the mailing lists: The changes are different, as far as git is
   concerned.

   To remove the development branch just do this:

#+BEGIN_EXAMPLE
% git branch -D ft/feature-x
#+END_EXAMPLE

* Features

  - One command to do all the work at once.
  - Support for X-Seq: numbers.
  - Support for mails to zsh-users (they get a "users/" prefix)
  - Support for amending commits with ChangeLog entries

* Installation

  The package consists of four scripts:

  - genchangelog: Generates the changelog entries.
  - zsh-am-xseq2subject: Amends Subject lines with "<number>:" and
    "users/<number>:" prefixes based on the X-Seq: headers.
  - zsh-am-and-changelog: Calls git-am and amends the ChangeLog along the way.
  - zsh-am: Calls zsh-am-xseq2subject and zsh-am-and-changelog in succession
    for any number of mbox files.

  The installation works like this:

#+BEGIN_EXAMPLE
# make install
#+END_EXAMPLE

  The default installation prefix is "/usr/local", so the scripts will end up
  in "/usr/local/bin". If you'd prefer them to live in "~/bin", do this:

#+BEGIN_EXAMPLE
% make install PREFIX="$HOME/bin"
#+END_EXAMPLE

  Similarly, the package may be uninstalled using:

#+BEGIN_EXAMPLE
# make uninstall
#+END_EXAMPLE

  After installing, you have to move to your zsh git clone and call zsh-am with
  its "-init" option:

#+BEGIN_EXAMPLE
% cd ~/src/zsh
% zsh-am -init
#+END_EXAMPLE

* One full example, finally.

#+BEGIN_EXAMPLE
% cd ~/src/zsh
% git checkout master
% git checkout -b ft/zle-init-hooks

  [..hack..hack..hack..]

% git format-patch master..
% git send-email --to='zsh-workers@zsh.org' --suppress-cc=all *.patch

  [..In MUA, mark mails and save them to "~/zle-init-hooks.mbox"..]

% git checkout master
% zsh-am ~/zle-init-hooks.mbox
% gitk --all ;: check if everything in master looks right
% git push
% rm ~/zle-init-hooks.mbox
% git branch -D ft/zle-init-hooks
#+END_EXAMPLE
